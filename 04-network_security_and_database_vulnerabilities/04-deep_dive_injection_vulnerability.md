<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Injection Vulnerability](#injection-vulnerability)
  - [Introduction to Injection Flaws](#introduction-to-injection-flaws)
    - [What are injection flaws?](#what-are-injection-flaws)
  - [OS Command Injection](#os-command-injection)
    - [What is OS Command Injection?](#what-is-os-command-injection)
      - [What is the Worst That Could Happen?](#what-is-the-worst-that-could-happen)
    - [How to Prevent OS Command Injection?](#how-to-prevent-os-command-injection)
      - [Recommendation #1 – don’t execute OS commands](#recommendation-1--dont-execute-os-commands)
      - [Recommendation #2 – Run at the least possible privilege level](#recommendation-2--run-at-the-least-possible-privilege-level)
      - [Recommendation #3 – Don’t run commands through shell interpreters](#recommendation-3--dont-run-commands-through-shell-interpreters)
      - [Recommendation #4 – Use explicit paths when running executables](#recommendation-4--use-explicit-paths-when-running-executables)
      - [Recommendation #5 – Use safer functions when running system commands](#recommendation-5--use-safer-functions-when-running-system-commands)
      - [Recommendation #6 – if possible, don’t let user input reach command execution unchanged](#recommendation-6--if-possible-dont-let-user-input-reach-command-execution-unchanged)
      - [Recommendation #7 – Sanitize user input with strict whitelist (not blacklists!)](#recommendation-7--sanitize-user-input-with-strict-whitelist-not-blacklists)
- [SQL Injection](#sql-injection)
  - [What is SQL Injection?](#what-is-sql-injection)
    - [Dangers of SQL Injection](#dangers-of-sql-injection)
    - [Common Types of SQL injection](#common-types-of-sql-injection)
  - [How to Prevent SQL Injection?](#how-to-prevent-sql-injection)
    - [Recommendation #1 – Use prepared statements](#recommendation-1--use-prepared-statements)
    - [Recommendation #2 – Sanitize user input](#recommendation-2--sanitize-user-input)
    - [Recommendation #3 – Don’t expose database errors to the user](#recommendation-3--dont-expose-database-errors-to-the-user)
    - [Recommendation #4 – Limit database user permissions](#recommendation-4--limit-database-user-permissions)
    - [Recommendation #5 – Use stored Procedures](#recommendation-5--use-stored-procedures)
    - [Recommendation #6 – Use ORM libraries](#recommendation-6--use-orm-libraries)
  - [Other Types of Injection](#other-types-of-injection)
    - [NoSQL Injection](#nosql-injection)
    - [XPath Injection](#xpath-injection)
    - [LDAP Injection](#ldap-injection)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Injection Vulnerability

## Introduction to Injection Flaws

### What are injection flaws?

- **Injection Flaws:** They allow attackers to relay malicious code through the vulnerable application to another system (OS, Database server, LDAP server, etc.)
- They are extremely dangerous, and may allow full takeover of the vulnerable system.
- **Injection flaws** appear internally and externally as a **Top Issue**.

## OS Command Injection

### What is OS Command Injection?

- Abuse of vulnerable application functionality that causes execution of attacker-specified OS commands.
- Applies to all OSes – Linux, Windows,macOS.
- Made possible by lack of sufficient input sanitization, and by unsafe execution of OS commands.

#### What is the Worst That Could Happen?

- Attacker can replace file to be deleted – BAD:
```bash
/bin/sh -c "/bin/rm /var/app/logs/../../lib/libc.so.6"
```
- Attacker can inject **arbitrary malicious OS command – MUCH WORSE:**
```shell
/bin/sh -c "/bin/rm /var/app/logs/x;rm -rf /"
```
- OS command injection can lead to:
	- Full system takeover
	- Denial of service
	- Stolen sensitive information (passwords, crypto keys, sensitive personal info, business confidential data)
	- Lateral movement on the network, launching pad for attacks on other systems
	- Use of system for botnets or cryptomining
- This is as bad as it gets, a “GAME OVER” event.

### How to Prevent OS Command Injection?

#### Recommendation #1 – don’t execute OS commands

- Sometimes OS command execution is introduced as a quick fix, to let the command or group of commands do the heavy lifting.
- This is dangerous, because insufficient input checks may let a destructive OS command slip in.
- Resist the temptation to run OS commands and use built-in or 3<sup>rd</sup> party libraries instead:
	- Instead of `rm` use `java.nio.file.Files.deleteIfExists(file)`
	- Instead of `cp` use `java.nio.file.Files.copy(source, destination)` … and so on.
- Use of library functions significantly reduces the attack surface.

####  Recommendation #2 – Run at the least possible privilege level

- It is a good idea to run under a user account with the least required rights.
- The more restricted the privilege level is, the less damage can be done.
- If an attacker is able to sneak in an OS command (e.g., `rm -rf /`) he can do much less damage when the application is running as `tomcat` user vs. running as `root` user.
- This helps in case of many vulnerabilities, not just injection.

#### Recommendation #3 – Don’t run commands through shell interpreters

- When you run shell interpreters like `sh, bash, cmd.exe, powershell.exe` it is much easier to inject commands.
- The following command allows injection of an extra `rm`:
```sh
/bin/sh -c "/bin/rm /var/app/logs/x;rm -rf /"
```
- … but in this case injection will not work, the whole command will fail:
```sh
/bin/rm /var/app/logs/x;rm -rf/
```
- Running a single command directly executes just that command.
- Note that it is still possible to influence the behavior of a single command (e.g., for `nmap` the part on the right, when injected, could overwrite a vital system file):
```sh
/usr/bin/nmap 1.2.3.4 -oX /lib/libc.so.6
```
- Also note that the parameters that you pass to a script may still result in command injection:
```sh
processfile.sh "x;rm -rf /"
```

#### Recommendation #4 – Use explicit paths when running executables

- Applications are found and executed based on system path settings.
- If a writable folder is referenced in the path before the folder containing the valid executable, an attacker may install a malicious version of the application there.
- In this case, the following command will cause execution of the malicious application:
```sh
/usr/bin/nmap 123.45.67.89
```
- The same considerations apply to shared libraries, explicit references help avoid `DLL` hijacking.

#### Recommendation #5 – Use safer functions when running system commands

- If available, use functionality that helps prevent command injection.
- For example, the following function call is vulnerable to new parameter injection (one could include more parameters, separated by spaces, in `ipAddress`):
```java
Runtime.getRuntime().exec("/user/bin/nmap " + ipAddress) ;
```
- … but this call is not vulnerable:
```java
Runtime.getRuntime().exec(new String[]{"/usr/bin/nmap",ipAddress});
```

#### Recommendation #6 – if possible, don’t let user input reach command execution unchanged

- Modifying user input, or replacing user-specified values with others (e.g., using translation tables) helps protect against injection.
- For example, instead of allowing a user to specify a file to delete, let them select a unique file ID:
```java
action=delete&file=457
```
- When submitted, translate that ID into a real file name:
```java
realName= getRealFileName(fileID);
Runtime.getRuntime().exec(newString[]{"/bin/rm","/var/app/logs/"+realName});
```

#### Recommendation #7 – Sanitize user input with strict whitelist (not blacklists!)

- In products, we often see blacklists used for parameter sanitization; some of them are incorrect.
- It is **hard** to build a successful blacklist – hackers are very inventive.
- Suppose we want to blacklist characters used in a file name for command, `rm /var/app/logs/file`
![](images/Pasted%20image%2020230321150154.png)
- A more robust and simpler solution is to whitelist file name as `[A-Za-z0-9.]+`

# SQL Injection

## What is SQL Injection?

- Abuse of vulnerable application functionality that causes execution of attacker-specified SQL queries.
- It is possible in any SQL database.
- Made possible by lack of sufficient input sanitization.

**Example**

![](images/Pasted%20image%2020230321151226.png)

### Dangers of SQL Injection

- Consequences of SQL injection:
	- Bypassing of authentication mechanisms
	- Data exfiltration
	- Execution of OS commands, e.g., in Postgres:
```postgres
COPY (SELECT 1) TO PROGRAM 'rm -rf /'
```
- Vandalism/DoS (e.g., `DROP TABLE sales`) – injected statements may sometimes be chained
```sql
SELECT * FROM users WHERE user='' ;DROP TABLE sales; --' AND pass=''
```

### Common Types of SQL injection

- **Error based**
	- Attacker may tailor his actions based on the database errors the application displays.
- **UNION-based**
	- May be used for data exfiltration, for example:
```SQL
SELECT name, text FROM log WHERE data='2018-04-01' UNION SELECT user, password FROM users --'
```
- **Blind Injection**
	- The query may not return the data directly, but it can be inferred by executing many queries whose behavior presents one of two outcomes.
	- Can be Boolean-based (one of two possible responses), and Time-based (immediate vs delayed execution).
	- For example, the following expression, when injected, indicates if the first letter of the password is `a`:
```sql
IF(password LIKE 'a%', sleep(10), 'false')
```
- **Out of Band**
	- Data exfiltration is done through a separate channel (e.g., by sending an HTTP request).

## How to Prevent SQL Injection?

### Recommendation #1 – Use prepared statements

- Most SQL injection happens because queries are pieced together as text.
- Use of prepared statements separates the query structure from query parameters.
- Instead of this pattern:
```sql
stmt.executeQuery("SELECT * FROM users WHERE user='"+user+"' AND pass='"pass+"'")
```
- … use this:
```sql
PreparedStatement ps = conn.preparedStatement("SELECT * FROM users WHERE user = ? AND pass = ?"); ps.setString(1, user);ps.setString(2, pass);
```
- SQL injection risk now mitigated.
- Note that prepared statements must be used properly, we occasionally see bad examples like:
```sql
conn.preparedStatement("SELECT * FROM users WHERE user = ? AND pass = ? ORDER BY "+column);
```

### Recommendation #2 – Sanitize user input

- Just like for OS command injection, input sanitization is important.
- Only restrictive whitelists should be used, not blacklists.
- Where appropriate, don’t allow user input to reach the database, and instead use mapping tables to translate it.

### Recommendation #3 – Don’t expose database errors to the user

- Application errors should not expose internal information to the user.
- Details belong in an internal log file.
- Exposed details can be abused for tailoring SQL injection commands.
- For examples, the following error message exposes both the internal query structure and the database type, helping attackers in their efforts:
> ERROR: If you have an error in your SQL syntax, check the manual that corresponds to your MySQL server version for the right syntax to use near `“x” GROUP BY username ORDER BY username ASC’ at line 1`.

### Recommendation #4 – Limit database user permissions

- When user queries are executed under a restricted user, less damage is possible if SQL injection happens.
- Consider using a user with read-only permissions when database updates are not required, or use different users for different operations.

### Recommendation #5 – Use stored Procedures

- Use of stored procedures mitigates the risk by moving SQL queries into the database engine.
- Fewer SQL queries will be under direct control of the application, reducing likelihood of abuse.

### Recommendation #6 – Use ORM libraries

- Object-relational mapping (ORM) libraries help mitigate SQL injection
	- Examples: Java Persistence API (JPA) implementations like Hibernate.
- ORM helps reduce or eliminate the need for direct SQL composition.
- However, if ORM is used improperly SQL injections may still be possible:
```sql
Query hqlQuery = session.createQuery("SELECT * FROM users WHERE user='"+user+"'AND pass='"+pass+"'")
```

## Other Types of Injection

- Injection flaws exist in many other technologies
- Apart from the following, there are injection flaws also exist in Templating engines.
- … and many other technologies
- Recommendation for avoiding all of them are similar to what is proposed for OS and SQL injection.

### NoSQL Injection

- In MongoDB `$where` query parameter is interpreted as JavaScript.
- Suppose we take an expression parameter as input:
```nosql
$where: "$expression"
```
- In simple case it is harmless:
```nosql
$where: "this.userType==3"
```
- However, an attacker can perform a DoS attack:
```nosql
$where: "d = new Date; do {c = new Date;} while (c - d < 100000;"
```

### XPath Injection

- Suppose we use XPath expressions to select user on login:
```xpath
"//Employee[UserName/text()='" + Request ("Username") + "' AND Password/text() = '" + Request ("Password") + "']"
```
- In the benign case, it will select only the user whose name and password match:
```xpath
//Employee[UserName/text()='bob' AND Password/text()='secret']
```
- In the malicious case, it will select any user:
```xpath
//Employee[UserName/text()='' or 1=1 or '1'='1' And Password/text()='']
```

### LDAP Injection

- LDAP is a common mechanism for managing user identity information. The following expression will find the user with the specified username and password.
```ldap
find("(&(cn=" + user +")(password=" + pass +"))")
```
- In the regular case, the LDAP expression will work only if the username and password match:
```ldap
find("(&(cn=bob)(password=secret))")
```
- Malicious users may tweak the username to force expression to find any user:
```ldap
find("(&(cn=*)(cn=*))(|cn=*)(password=any)")
```
